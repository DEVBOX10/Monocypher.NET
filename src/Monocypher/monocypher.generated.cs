//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Monocypher
{
    using System.Runtime.InteropServices;
    
    public static partial class monocypher
    {
        /// <summary>
        /// Vtable for EdDSA with a custom hash.
        /// Instantiate it to define a custom hash.
        /// Its size, contents, and layout, are part of the public API.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct crypto_sign_vtable
        {
            public monocypher.crypto_sign_vtable.hash_delegate hash;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void hash_delegate(ref Byte64 hash, IntPtr message, monocypher.size_t message_size);
            
            public monocypher.crypto_sign_vtable.init_delegate init;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void init_delegate(IntPtr ctx);
            
            public monocypher.crypto_sign_vtable.update_delegate update;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void update_delegate(IntPtr ctx, IntPtr message, monocypher.size_t message_size);
            
            public monocypher.crypto_sign_vtable.final_delegate final;
            
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void final_delegate(IntPtr ctx, ref Byte64 hash);
            
            public monocypher.size_t ctx_size;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct size_t : IEquatable<size_t>
        {
            public size_t(IntPtr value) => this.Value = value;
            
            public readonly IntPtr Value;
            
            public bool Equals(size_t other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is size_t other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator IntPtr(size_t from) => from.Value;
            
            public static implicit operator size_t(IntPtr from) => new size_t(from);
            
            public static bool operator ==(size_t left, size_t right) => left.Equals(right);
            
            public static bool operator !=(size_t left, size_t right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Poly1305
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct crypto_poly1305_ctx
        {
            /// <summary>
            /// constant multiplier (from the secret key)
            /// </summary>
            public fixed uint r[4];
            
            /// <summary>
            /// accumulated hash
            /// </summary>
            public fixed uint h[5];
            
            /// <summary>
            /// chunk of the message
            /// </summary>
            public fixed uint c[5];
            
            /// <summary>
            /// random number added at the end (from the secret key)
            /// </summary>
            public fixed uint pad[4];
            
            /// <summary>
            /// How many bytes are there in the chunk.
            /// </summary>
            public monocypher.size_t c_idx;
        }
        
        /// <summary>
        /// Hash (Blake2b)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct crypto_blake2b_ctx
        {
            public fixed ulong hash[8];
            
            public fixed ulong input_offset[2];
            
            public fixed ulong input[16];
            
            public monocypher.size_t input_idx;
            
            public monocypher.size_t hash_size;
        }
        
        /// <summary>
        /// Signatures (EdDSA)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct crypto_sign_ctx_abstract
        {
            public IntPtr hash;
            
            public fixed byte buf[96];
            
            public fixed byte pk[32];
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct crypto_sign_ctx
        {
            public monocypher.crypto_sign_ctx_abstract ctx;
            
            public monocypher.crypto_blake2b_ctx hash;
        }
        
        /// <summary>
        /// Do not rely on the size or content on any of those types,
        /// they may change without notice.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct crypto_sha512_ctx
        {
            public fixed ulong hash[8];
            
            public fixed ulong input[16];
            
            public fixed ulong input_size[2];
            
            public monocypher.size_t input_idx;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct crypto_hmac_sha512_ctx
        {
            public fixed byte key[128];
            
            public monocypher.crypto_sha512_ctx ctx;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct crypto_sign_ed25519_ctx
        {
            public monocypher.crypto_sign_ctx_abstract ctx;
            
            public monocypher.crypto_sha512_ctx hash;
        }
        
        /// <summary>
        /// Signatures (EdDSA)
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct crypto_check_ctx_abstract : IEquatable<crypto_check_ctx_abstract>
        {
            public crypto_check_ctx_abstract(monocypher.crypto_sign_ctx_abstract value) => this.Value = value;
            
            public readonly monocypher.crypto_sign_ctx_abstract Value;
            
            public bool Equals(crypto_check_ctx_abstract other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is crypto_check_ctx_abstract other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator monocypher.crypto_sign_ctx_abstract(crypto_check_ctx_abstract from) => from.Value;
            
            public static implicit operator crypto_check_ctx_abstract(monocypher.crypto_sign_ctx_abstract from) => new crypto_check_ctx_abstract(from);
            
            public static bool operator ==(crypto_check_ctx_abstract left, crypto_check_ctx_abstract right) => left.Equals(right);
            
            public static bool operator !=(crypto_check_ctx_abstract left, crypto_check_ctx_abstract right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct crypto_check_ctx : IEquatable<crypto_check_ctx>
        {
            public crypto_check_ctx(monocypher.crypto_sign_ctx value) => this.Value = value;
            
            public readonly monocypher.crypto_sign_ctx Value;
            
            public bool Equals(crypto_check_ctx other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is crypto_check_ctx other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator monocypher.crypto_sign_ctx(crypto_check_ctx from) => from.Value;
            
            public static implicit operator crypto_check_ctx(monocypher.crypto_sign_ctx from) => new crypto_check_ctx(from);
            
            public static bool operator ==(crypto_check_ctx left, crypto_check_ctx right) => left.Equals(right);
            
            public static bool operator !=(crypto_check_ctx left, crypto_check_ctx right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct crypto_check_ed25519_ctx : IEquatable<crypto_check_ed25519_ctx>
        {
            public crypto_check_ed25519_ctx(monocypher.crypto_sign_ed25519_ctx value) => this.Value = value;
            
            public readonly monocypher.crypto_sign_ed25519_ctx Value;
            
            public bool Equals(crypto_check_ed25519_ctx other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is crypto_check_ed25519_ctx other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator monocypher.crypto_sign_ed25519_ctx(crypto_check_ed25519_ctx from) => from.Value;
            
            public static implicit operator crypto_check_ed25519_ctx(monocypher.crypto_sign_ed25519_ctx from) => new crypto_check_ed25519_ctx(from);
            
            public static bool operator ==(crypto_check_ed25519_ctx left, crypto_check_ed25519_ctx right) => left.Equals(right);
            
            public static bool operator !=(crypto_check_ed25519_ctx left, crypto_check_ed25519_ctx right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Return 0 if a and b are equal, -1 otherwise
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_verify16(in Byte16 a, in Byte16 b);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_verify32(in Byte32 a, in Byte32 b);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_verify64(in Byte64 a, in Byte64 b);
        
        /// <summary>
        /// Please erase all copies
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_wipe(IntPtr secret, monocypher.size_t size);
        
        /// <summary>
        /// Authenticated encryption
        /// ------------------------
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_lock(ref Byte16 mac, IntPtr cipher_text, in Byte32 key, in Byte24 nonce, IntPtr plain_text, monocypher.size_t text_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_unlock(IntPtr plain_text, in Byte32 key, in Byte24 nonce, in Byte16 mac, IntPtr cipher_text, monocypher.size_t text_size);
        
        /// <summary>
        /// With additional data
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_lock_aead(ref Byte16 mac, IntPtr cipher_text, in Byte32 key, in Byte24 nonce, IntPtr ad, monocypher.size_t ad_size, IntPtr plain_text, monocypher.size_t text_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_unlock_aead(IntPtr plain_text, in Byte32 key, in Byte24 nonce, in Byte16 mac, IntPtr ad, monocypher.size_t ad_size, IntPtr cipher_text, monocypher.size_t text_size);
        
        /// <summary>
        /// Direct interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_blake2b(ref Byte64 hash, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_blake2b_general(IntPtr hash, monocypher.size_t hash_size, IntPtr key, monocypher.size_t key_size, IntPtr message, monocypher.size_t message_size);
        
        /// <summary>
        /// Incremental interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_blake2b_init(ref monocypher.crypto_blake2b_ctx ctx);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_blake2b_update(ref monocypher.crypto_blake2b_ctx ctx, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_blake2b_final(ref monocypher.crypto_blake2b_ctx ctx, IntPtr hash);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_blake2b_general_init(ref monocypher.crypto_blake2b_ctx ctx, monocypher.size_t hash_size, IntPtr key, monocypher.size_t key_size);
        
        /// <summary>
        /// Password key derivation (Argon2 i)
        /// ----------------------------------
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_argon2i(IntPtr hash, uint hash_size, IntPtr work_area, uint nb_blocks, uint nb_iterations, IntPtr password, uint password_size, IntPtr salt, uint salt_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_argon2i_general(IntPtr hash, uint hash_size, IntPtr work_area, uint nb_blocks, uint nb_iterations, IntPtr password, uint password_size, IntPtr salt, uint salt_size, IntPtr key, uint key_size, IntPtr ad, uint ad_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_key_exchange(ref Byte32 shared_key, in Byte32 your_secret_key, in Byte32 their_public_key);
        
        /// <summary>
        /// Generate public key
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign_public_key(ref Byte32 public_key, in Byte32 secret_key);
        
        /// <summary>
        /// Direct interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign(ref Byte64 signature, in Byte32 secret_key, in Byte32 public_key, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_check(in Byte64 signature, in Byte32 public_key, IntPtr message, monocypher.size_t message_size);
        
        /// <summary>
        /// Specialised hash.
        /// Used to hash X25519 shared secrets.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_hchacha20(ref Byte32 @out, in Byte32 key, in Byte16 @in);
        
        /// <summary>
        /// Unauthenticated stream cipher.
        /// Don't forget to add authentication.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_chacha20(IntPtr cipher_text, IntPtr plain_text, monocypher.size_t text_size, in Byte32 key, in Byte8 nonce);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_xchacha20(IntPtr cipher_text, IntPtr plain_text, monocypher.size_t text_size, in Byte32 key, in Byte24 nonce);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_ietf_chacha20(IntPtr cipher_text, IntPtr plain_text, monocypher.size_t text_size, in Byte32 key, in Byte12 nonce);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong crypto_chacha20_ctr(IntPtr cipher_text, IntPtr plain_text, monocypher.size_t text_size, in Byte32 key, in Byte8 nonce, ulong ctr);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong crypto_xchacha20_ctr(IntPtr cipher_text, IntPtr plain_text, monocypher.size_t text_size, in Byte32 key, in Byte24 nonce, ulong ctr);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint crypto_ietf_chacha20_ctr(IntPtr cipher_text, IntPtr plain_text, monocypher.size_t text_size, in Byte32 key, in Byte12 nonce, uint ctr);
        
        /// <summary>
        /// Direct interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_poly1305(ref Byte16 mac, IntPtr message, monocypher.size_t message_size, in Byte32 key);
        
        /// <summary>
        /// Incremental interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_poly1305_init(ref monocypher.crypto_poly1305_ctx ctx, in Byte32 key);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_poly1305_update(ref monocypher.crypto_poly1305_ctx ctx, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_poly1305_final(ref monocypher.crypto_poly1305_ctx ctx, ref Byte16 mac);
        
        /// <summary>
        /// Shared secrets are not quite random.
        /// Hash them to derive an actual shared key.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_x25519_public_key(ref Byte32 public_key, in Byte32 secret_key);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_x25519(ref Byte32 raw_shared_secret, in Byte32 your_secret_key, in Byte32 their_public_key);
        
        /// <summary>
        /// "Dirty" versions of x25519_public_key()
        /// Only use to generate ephemeral keys you want to hide.
        /// Note that those functions leaks 3 bits of the private key.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_x25519_dirty_small(ref Byte32 pk, in Byte32 sk);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_x25519_dirty_fast(ref Byte32 pk, in Byte32 sk);
        
        /// <summary>
        /// scalar "division"
        /// Used for OPRF.  Be aware that exponential blinding is less secure
        /// than Diffie-Hellman key exchange.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_x25519_inverse(ref Byte32 blind_salt, in Byte32 private_key, in Byte32 curve_point);
        
        /// <summary>
        /// EdDSA to X25519
        /// ---------------
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_from_eddsa_private(ref Byte32 x25519, in Byte32 eddsa);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_from_eddsa_public(ref Byte32 x25519, in Byte32 eddsa);
        
        /// <summary>
        /// Signing (2 passes)
        /// Make sure the two passes hash the same message,
        /// else you might reveal the private key.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign_init_first_pass(ref monocypher.crypto_sign_ctx_abstract ctx, in Byte32 secret_key, in Byte32 public_key);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign_update(ref monocypher.crypto_sign_ctx_abstract ctx, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign_init_second_pass(ref monocypher.crypto_sign_ctx_abstract ctx);
        
        /// <summary>
        /// use crypto_sign_update() again.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign_final(ref monocypher.crypto_sign_ctx_abstract ctx, ref Byte64 signature);
        
        /// <summary>
        /// Verification (1 pass)
        /// Make sure you don't use (parts of) the message
        /// before you're done checking it.
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_check_init(ref monocypher.crypto_check_ctx_abstract ctx, in Byte64 signature, in Byte32 public_key);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_check_update(ref monocypher.crypto_check_ctx_abstract ctx, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_check_final(ref monocypher.crypto_check_ctx_abstract ctx);
        
        /// <summary>
        /// Custom hash interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign_public_key_custom_hash(ref Byte32 public_key, in Byte32 secret_key, in monocypher.crypto_sign_vtable hash);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sign_init_first_pass_custom_hash(ref monocypher.crypto_sign_ctx_abstract ctx, in Byte32 secret_key, in Byte32 public_key, in monocypher.crypto_sign_vtable hash);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_check_init_custom_hash(ref monocypher.crypto_check_ctx_abstract ctx, in Byte64 signature, in Byte32 public_key, in monocypher.crypto_sign_vtable hash);
        
        /// <summary>
        /// Elligator mappings proper
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_hidden_to_curve(ref Byte32 curve, in Byte32 hidden);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_curve_to_hidden(ref Byte32 hidden, in Byte32 curve, byte tweak);
        
        /// <summary>
        /// Easy to use key pair generation
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_hidden_key_pair(ref Byte32 hidden, ref Byte32 secret_key, ref Byte32 seed);
        
        /// <summary>
        /// SHA 512
        /// -------
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sha512_init(ref monocypher.crypto_sha512_ctx ctx);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sha512_update(ref monocypher.crypto_sha512_ctx ctx, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sha512_final(ref monocypher.crypto_sha512_ctx ctx, ref Byte64 hash);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_sha512(ref Byte64 hash, IntPtr message, monocypher.size_t message_size);
        
        /// <summary>
        /// HMAC SHA 512
        /// ------------
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_hmac_sha512_init(ref monocypher.crypto_hmac_sha512_ctx ctx, IntPtr key, monocypher.size_t key_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_hmac_sha512_update(ref monocypher.crypto_hmac_sha512_ctx ctx, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_hmac_sha512_final(ref monocypher.crypto_hmac_sha512_ctx ctx, ref Byte64 hmac);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_hmac_sha512(ref Byte64 hmac, IntPtr key, monocypher.size_t key_size, IntPtr message, monocypher.size_t message_size);
        
        /// <summary>
        /// Generate public key
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_ed25519_public_key(ref Byte32 public_key, in Byte32 secret_key);
        
        /// <summary>
        /// Direct interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_ed25519_sign(ref Byte64 signature, in Byte32 secret_key, in Byte32 public_key, IntPtr message, monocypher.size_t message_size);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern int crypto_ed25519_check(in Byte64 signature, in Byte32 public_key, IntPtr message, monocypher.size_t message_size);
        
        /// <summary>
        /// Incremental interface
        /// </summary>
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_ed25519_sign_init_first_pass(ref monocypher.crypto_sign_ctx_abstract ctx, in Byte32 secret_key, in Byte32 public_key);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_ed25519_check_init(ref monocypher.crypto_check_ctx_abstract ctx, in Byte64 signature, in Byte32 public_key);
        
        [DllImport(MonocypherDll, CallingConvention = CallingConvention.Cdecl)]
        public static extern void crypto_from_ed25519_private(ref Byte32 x25519, in Byte32 eddsa);
    }
}
